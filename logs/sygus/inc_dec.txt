PDSC: Verifying ./Benchmarks_sygus/inc_dec.smt2
Namespace(file='./Benchmarks_sygus/inc_dec.smt2', log=False, msat=False, property=None, qe=False, sygus=True)
Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[2]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count1_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count1_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
count0_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
count0_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
count0_eq_2, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]


Blocking composition assignment 0 for state
 [count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]


Blocking composition assignment 0 for state
 [count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count1_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count1_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]


17 SMT queries performed.
-----------------check_spuriousness-------------------------------



SEARCHING A CONCRETE CEX TRACE FROM ABOVE ABSTRACT CEX: 
--------------------------------------------------
Initial State {'h_1': 1, 'h_0': 1, 'h_gt_0_1': True, 'count_eq_0_1': True, 'h_gt_0_0': True, 'count_eq_0_0': True, 'count1_eq_2': False, 'count0_eq_2': False, 'l0_eq_l1': True, 'l_1': 0, 'l_0': 0, 'count_1': 0, 'count_0': 0}


Next concrete state : {'count_1': 1, 'l_1': 1, 'count_0': 0, 'h_0': 1, 'l_0': 0, 'h_1': 1}


Next concrete state : {'count_1': 2, 'l_1': 0, 'count_0': 0, 'h_0': 1, 'l_0': 0, 'h_1': 1}





Is the abstract trace spurious? True
---------------pred_disc--------------
Discover predicate using a_src, a_tgt, c_src, c_tgt to eliminate the spurious cex.. 












new predicate is (define-fun p ((h_1 Int) (l_0 Int) (count_0 Int) (h_0 Int) (count_1 Int) (l_1 Int)) Bool (= h_1 (- l_1 l_0)))

Failed to find semantic self-composition. Either the property is violated or not enough predicates were supplied.
Pre-processing time:	0.044661 
Solver time:	2.853398
Total time:	2.898059
Iteration count:	17
Predicate count:	7
Successfully added new predicate to input file. !
PDSC: Verifying ./Benchmarks_sygus/inc_dec.smt2
Namespace(file='./Benchmarks_sygus/inc_dec.smt2', log=False, msat=False, property=None, qe=False, sygus=True)
Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[2]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count0_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count0_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count0_eq_2, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
count0_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
count0_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
count0_eq_2, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]


Blocking composition assignment 0 for state
 [count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
p_synth_1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
p_synth_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
p_synth_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]


Blocking composition assignment 0 for state
 [count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
p_synth_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
p_synth_1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count1_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count1_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
p_synth_1, ]
--->[1]

[count_eq_0_0, 
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, 
count1_eq_2, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]


16 SMT queries performed.
-----------------check_spuriousness-------------------------------



SEARCHING A CONCRETE CEX TRACE FROM ABOVE ABSTRACT CEX: 
--------------------------------------------------
Initial State {'h_1': 1, 'h_0': 1, 'h_gt_0_1': True, 'count_eq_0_1': True, 'h_gt_0_0': True, 'count_eq_0_0': True, 'p_synth_1': False, 'count1_eq_2': False, 'count0_eq_2': False, 'l0_eq_l1': True, 'l_1': 0, 'l_0': 0, 'count_1': 0, 'count_0': 0}


Next concrete state : {'count_1': 1, 'l_1': 1, 'count_0': 0, 'h_0': 1, 'l_0': 0, 'h_1': 1}


Next concrete state : {'count_1': 2, 'l_1': 0, 'count_0': 0, 'h_0': 1, 'l_0': 0, 'h_1': 1}


Next concrete state : {'count_0': 1, 'l_0': 1, 'count_1': 2, 'h_1': 1, 'l_1': 0, 'h_0': 1}


Next concrete state : {'count_0': 2, 'l_0': 0, 'count_1': 2, 'h_1': 1, 'l_1': 0, 'h_0': 1}





Is the abstract trace spurious? True
---------------pred_disc--------------
Discover predicate using a_src, a_tgt, c_src, c_tgt to eliminate the spurious cex.. 












new predicate is (define-fun p ((h_1 Int) (l_0 Int) (count_0 Int) (h_0 Int) (count_1 Int) (l_1 Int)) Bool (= l_0 (+ h_0 l_1)))

Failed to find semantic self-composition. Either the property is violated or not enough predicates were supplied.
Pre-processing time:	0.052327 
Solver time:	3.395444
Total time:	3.447771
Iteration count:	16
Predicate count:	8
Successfully added new predicate to input file. !
Start next refinement loop: True



PDSC: Verifying ./Benchmarks_sygus/inc_dec.smt2
Namespace(file='./Benchmarks_sygus/inc_dec.smt2', log=False, msat=False, property=None, qe=False, sygus=True)
Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[2]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, ]
--->[0]


Blocking composition assignment 0 for state
 [
h_gt_0_0, 
h_gt_0_1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[1]

[
h_gt_0_0, 
h_gt_0_1, 
count1_eq_2, ]
--->[0]

[
h_gt_0_0, 
h_gt_0_1, 
count0_eq_2, 
count1_eq_2, ]
--->[0]


Blocking composition assignment 2 for state
 [count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]


Exploring new composition...


Current composition gives an abstract counter-example trace:
[count_eq_0_0, 
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]

[
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
p_synth_2, ]
--->[2]

[
h_gt_0_0, 
h_gt_0_1, 
l0_eq_l1, ]
--->[0]


Blocking composition assignment 2 for state
 [
h_gt_0_0, 
count_eq_0_1, 
h_gt_0_1, 
p_synth_2, ]


9 SMT queries performed.
Proved by invariant:
And(h_gt_0_0,
    Or(count_eq_0_0, p_synth_2, count0_eq_2),
    h_gt_0_1,
    Or(l0_eq_l1, Not(count_eq_0_0)),
    Or(count0_eq_2, count_eq_0_1),
    Or(Not(p_synth_1), Not(count_eq_0_1)),
    Or(l0_eq_l1, Not(count0_eq_2), Not(count_eq_0_1)),
    Or(p_synth_1, count1_eq_2, count_eq_0_1),
    Or(Not(count1_eq_2), l0_eq_l1))
Pre-processing time:	0.06546 
Solver time:	0.890702
Total time:	0.956162
Iteration count:	9
Predicate count:	9
Start next refinement loop: False



Total time taken : 7.302518
Number of predicates guessed: 2.0
